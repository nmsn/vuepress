# 深入浅出Nodejs

## 1 Node简介

### 1.4 Node特点

- 异步I/O

- 事件与回调函数

- 单线程

  优点:

  - 没有死锁
  - 没有线程上下文交换所带来的性能上的开销

  缺点:

  - 无法利用多核CPU
  - 错误会引起整个应用退出，应用的健壮性值得考验
  - 大量计算占用CPU导致无法继续调用异步I/O

- 跨平台

### 2.2.3

Javascript模块的编译

在编译过程中，Node对于获取的JavaScript文件进行了头尾包装

在头部添加了

```js
(function (exports, require, module, __filename, dirname)) {\n
```

- filename: 返回当前模块文件被解析过后的绝对路径
- dirname: 返回当前模块文件解析过后所在的文件夹（目录）的绝对路径

在尾部添加了

```js
\n });
```

exports和module.exports

module.exports才是真正的接口，exports只不过是它的一个辅助工具。
最终返回给调用的是module.exports而不是exports。
所有的exports收集到的属性和方法，都赋值给了Module.exports。
当然，这有个前提，就是module.exports本身不具备任何属性和方法。
如果，module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。

### 2.3.2

模块依赖关系: 内建模块（c/c++） -> 核心模块(javascript) -> 文件模块

node在启动时会生成一个全局变量process

### 2.4

C/C++拓展模块属于文件模块的一类，预先编译为.node文件，然后调用process.dlopen()方法加载执行

为了实现跨平台， dlopen()在内部实现时区分了平台，分别用的是加载.so(*nix)和.dll(Window)的方式

### 2.6.1

包目录

- package.json 包描述文件
- bin 用于存放可执行二进制文件的目录
- lib 用于存放javaScript代码的目录
- doc 用于存放文档的目录
- test 用于存放单元测试用例的代码

### 2.7 

模块规范

- CommonJS
- AMD
- CMD

## 3 异步I/O

### 3.1.1

|I/O类型|花费的CPU时钟周期|
|---|---|
|CPU一级缓存|3|
|CPU二级缓存|14|
|内存|250|
|硬盘|41000000|
|网络|240000000|

### 3.2.1

- 阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束
- 非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升明显。但是由于完整的I/O并没有结束，立即返回的不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询。

- 任何技术都并非完美。阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理处理状态判断，是对CPU资源的浪费

轮询技术

- **read** 最原始性能最低，重复调用来检查I/O状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上
- **select** read基础上的改进，通过对文件描述符上的时间状态来进行判断（限制为采用1024长度的数组来存储状态）
- **poll** 较select有所改进，采用链表的方式避免数组长度的限制，其次能避免不需要的检查，但是当文件描述符较多时，性能还是十分低下
- **epoll** Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高
- **kequeue** 实现方式类似epoll，在FreeBSD系统下存在

### 3.3.5

- 在Node中，Javascript是单线程的，Node自身是多线程的，只是I/O线程使用的CPU较少
- 除了用户代码无法并行执行外，所有的I/O(磁盘I/O和网络I/O)则是可以并行的

### 3.4.1

setTimeout()和serInterval()与浏览器中的API是一致的，实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代去除定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的会掉函数将立即执行。

### 3.4.2

- setTimeout()/setInterval() 需要动用红黑树，比较浪费性能 时间复杂度O(lg(n))
- process.nextTick() 相对轻量，只会将回调函数放入队列中，在下一轮Tick时取出执行 时间复杂度O(1)
- setImmediate() 与process.nextTick()相似，区别是process.nextTick()中的回调函数执行的优先级要高于setImmediate()
  - process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者
  - 在实现上，process.nextTick的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中
  - 在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数

之所以这这样设计，是为了保证每轮循环能够较快地执行结束，防止CPU占用过多而阻塞后续I/O调用的情况